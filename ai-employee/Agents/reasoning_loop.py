"""
Reasoning Loop â€” Plan.md Creator with Ralph Wiggum Stop Hook
===============================================================
Core reasoning agent that:
  1. Reads files in /Needs_Action and /Accounting
  2. Creates structured Plan.md files with checklists
  3. Implements the Ralph Wiggum Stop Hook pattern:
     - Keeps iterating until all tasks are marked done
     - Only stops when /Needs_Action is empty

Usage:
    python Agents/reasoning_loop.py              # continuous loop
    python Agents/reasoning_loop.py --once       # single pass
"""

import sys
import time
import re
from pathlib import Path
from datetime import datetime, timezone

try:
    from Agents.config import (
        NEEDS_ACTION_DIR, DONE_DIR, ACCOUNTING_DIR,
        PENDING_APPROVAL_DIR, DRY_RUN, now_iso, now_local_iso,
    )
    from Agents.action_logger import log_action
except ImportError:
    from config import (
        NEEDS_ACTION_DIR, DONE_DIR, ACCOUNTING_DIR,
        PENDING_APPROVAL_DIR, DRY_RUN, now_iso, now_local_iso,
    )
    from action_logger import log_action


LOOP_INTERVAL = 15  # seconds between reasoning passes

# â”€â”€ Keyword â†’ action mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ACTION_RULES = {
    "email":    {"action": "draft_email_reply", "needs_approval": True},
    "reply":    {"action": "draft_email_reply", "needs_approval": True},
    "respond":  {"action": "draft_email_reply", "needs_approval": True},
    "invoice":  {"action": "log_invoice",       "needs_approval": False},
    "payment":  {"action": "log_payment",       "needs_approval": False},
    "deploy":   {"action": "deploy_checklist",  "needs_approval": True},
    "post":     {"action": "draft_social_post", "needs_approval": True},
    "linkedin": {"action": "draft_social_post", "needs_approval": True},
    "schedule": {"action": "schedule_task",     "needs_approval": False},
    "review":   {"action": "create_review",     "needs_approval": False},
    "urgent":   {"action": "escalate",          "needs_approval": False},
    "fix":      {"action": "create_fix_plan",   "needs_approval": False},
    "approve":  {"action": "request_approval",  "needs_approval": True},
}


def _extract_metadata(content: str) -> dict:
    """Parse YAML frontmatter from .md file content."""
    meta = {}
    match = re.match(r"^---\s*\n(.*?)\n---", content, re.DOTALL)
    if match:
        for line in match.group(1).splitlines():
            if ":" in line:
                key, _, val = line.partition(":")
                meta[key.strip()] = val.strip()
    return meta


def _detect_actions(content: str) -> list[dict]:
    """Determine required actions from file content using keyword rules."""
    lower = content.lower()
    matched = []
    for keyword, rule in ACTION_RULES.items():
        if keyword in lower:
            matched.append({"keyword": keyword, **rule})
    return matched or [{"keyword": "general", "action": "manual_review", "needs_approval": False}]


def _build_plan(filepath: Path, content: str, metadata: dict) -> str:
    """Generate a Plan.md document with a checklist for a task."""
    actions = _detect_actions(content)
    priority = metadata.get("priority", "normal")
    source = metadata.get("source", "unknown")
    watcher = metadata.get("watcher", "manual")

    priority_icon = {"urgent": "ðŸ”´", "normal": "ðŸŸ¡", "low": "ðŸŸ¢"}.get(priority, "âšª")

    checklist_lines = []
    for i, act in enumerate(actions, 1):
        approval_tag = " âš ï¸ *HITL approval required*" if act["needs_approval"] else ""
        checklist_lines.append(f"- [ ] **Step {i}:** `{act['action']}`{approval_tag}")
        if act["needs_approval"]:
            checklist_lines.append(f"  - [ ] Create approval request in /Pending_Approval")
            checklist_lines.append(f"  - [ ] Wait for approval â†’ /Approved")
            checklist_lines.append(f"  - [ ] Execute action")
        checklist_lines.append(f"  - [ ] Log result")

    checklist_lines.append(f"- [ ] **Final:** Move to /Done")

    plan = f"""---
type: plan
source_file: {filepath.name}
priority: {priority}
created_at: {now_iso()}
status: in_progress
---

# ðŸ“‹ Plan: {filepath.stem}

{priority_icon} **Priority:** {priority}
**Source:** {source}
**Watcher:** {watcher}
**Created:** {now_local_iso()}

---

## ðŸ“ Checklist

{chr(10).join(checklist_lines)}

---

## ðŸ“Ž Original Content

> {content[:500].replace(chr(10), chr(10) + '> ')}

---

> *Plan auto-generated by reasoning_loop*
"""
    return plan


def _create_approval_request(filepath: Path, action: dict) -> Path:
    """Create an APPROVAL_REQUIRED file in /Pending_Approval."""
    ts = datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%S")
    approval_file = PENDING_APPROVAL_DIR / f"APPROVAL_REQUIRED_{ts}_{action['action']}.md"

    content = f"""---
type: approval_request
action: {action['action']}
source_file: {filepath.name}
requested_at: {now_iso()}
status: pending
---

# âš ï¸ Approval Required: {action['action']}

**Action:** `{action['action']}`
**Triggered by:** `{filepath.name}`
**Keyword match:** `{action['keyword']}`
**Time:** {now_local_iso()}

---

## Instructions

To approve this action:
1. Review the details above
2. Move this file to `/Approved/`
3. The system will execute the action on next loop

To reject:
1. Move this file to `/Done/` (it will be archived without execution)

---

> *Auto-generated by reasoning_loop â€” Human-in-the-Loop safeguard*
"""
    approval_file.write_text(content, encoding="utf-8")
    log_action(
        action_type="approval_requested",
        actor="reasoning_loop",
        target=approval_file.name,
        description=f"HITL approval requested for {action['action']}",
        approval_status="pending",
    )
    return approval_file


def process_needs_action() -> dict:
    """
    Single reasoning pass:
    - Read all files in /Needs_Action
    - Create Plan.md for each
    - Create approval requests where needed
    - Return summary of actions taken
    """
    summary = {"processed": 0, "plans_created": 0, "approvals_requested": 0, "skipped": 0}

    for filepath in sorted(NEEDS_ACTION_DIR.iterdir()):
        if filepath.name.startswith(".") or not filepath.is_file():
            continue
        if filepath.name.startswith("Plan_"):
            continue  # don't process existing plans

        content = filepath.read_text(encoding="utf-8", errors="replace")
        metadata = _extract_metadata(content)

        # Skip if already has a plan
        plan_name = f"Plan_{filepath.stem}.md"
        plan_path = NEEDS_ACTION_DIR / plan_name
        if plan_path.exists():
            summary["skipped"] += 1
            continue

        # Build plan
        plan_content = _build_plan(filepath, content, metadata)
        plan_path.write_text(plan_content, encoding="utf-8")
        summary["plans_created"] += 1
        print(f"  ðŸ“‹  Plan created: {plan_name}")

        log_action(
            action_type="plan_created",
            actor="reasoning_loop",
            target=plan_name,
            description=f"Plan created for {filepath.name}",
        )

        # Create approval requests for actions that need HITL
        actions = _detect_actions(content)
        for act in actions:
            if act["needs_approval"]:
                ap = _create_approval_request(filepath, act)
                summary["approvals_requested"] += 1
                print(f"  âš ï¸  Approval requested: {ap.name}")

        summary["processed"] += 1

    return summary


def process_accounting() -> dict:
    """Scan /Accounting for items that need plans."""
    summary = {"processed": 0, "plans_created": 0}

    for filepath in sorted(ACCOUNTING_DIR.iterdir()):
        if filepath.name.startswith(".") or not filepath.is_file():
            continue
        if filepath.name.startswith("Plan_"):
            continue

        content = filepath.read_text(encoding="utf-8", errors="replace")
        metadata = _extract_metadata(content)

        plan_name = f"Plan_{filepath.stem}.md"
        plan_path = ACCOUNTING_DIR / plan_name
        if plan_path.exists():
            continue

        plan_content = _build_plan(filepath, content, metadata)
        plan_path.write_text(plan_content, encoding="utf-8")
        summary["plans_created"] += 1
        print(f"  ðŸ“‹  Accounting plan created: {plan_name}")

        log_action(
            action_type="plan_created",
            actor="reasoning_loop",
            target=plan_name,
            description=f"Accounting plan for {filepath.name}",
        )
        summary["processed"] += 1

    return summary


def ralph_wiggum_check() -> bool:
    """
    Ralph Wiggum Stop Hook:
    Returns True if there is still work to do (keep iterating).
    Returns False if all work is done (safe to stop).
    """
    actionable_files = [
        f for f in NEEDS_ACTION_DIR.iterdir()
        if f.is_file() and not f.name.startswith(".") and not f.name.startswith("Plan_")
    ]
    return len(actionable_files) > 0


def run_once() -> None:
    """Execute a single reasoning pass."""
    print(f"\nðŸ§   Reasoning Loop â€” {now_local_iso()}")
    print(f"    Scanning: /Needs_Action, /Accounting\n")

    na = process_needs_action()
    ac = process_accounting()

    print(f"\n    ðŸ“Š  Needs_Action: {na['processed']} processed, "
          f"{na['plans_created']} plans, {na['approvals_requested']} approvals")
    print(f"    ðŸ“Š  Accounting:   {ac['processed']} processed, "
          f"{ac['plans_created']} plans")

    still_working = ralph_wiggum_check()
    if still_working:
        print(f"    ðŸ”„  Ralph Wiggum: Still work to do â€” will continue.")
    else:
        print(f"    âœ…  Ralph Wiggum: All clear â€” nothing pending.")


def reasoning_loop() -> None:
    """Continuous reasoning loop with Ralph Wiggum Stop Hook."""
    print("ðŸ§   Reasoning Loop started â€” Ralph Wiggum Stop Hook active")
    print(f"    Interval: {LOOP_INTERVAL}s  |  Press Ctrl+C to stop\n")

    try:
        while True:
            run_once()

            if not ralph_wiggum_check():
                print("\n    ðŸ’¤  No pending work. Sleeping until next check...")

            time.sleep(LOOP_INTERVAL)
    except KeyboardInterrupt:
        print("\nðŸ›‘  Reasoning loop stopped by user.")


# â”€â”€ Entry point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    if "--once" in sys.argv:
        run_once()
    else:
        reasoning_loop()
