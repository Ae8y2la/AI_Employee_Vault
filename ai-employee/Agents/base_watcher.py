"""
BaseWatcher ‚Äî Abstract Template for All Watchers
==================================================
All watchers (Gmail, WhatsApp, LinkedIn, Filesystem) inherit from this class.
Provides common polling, logging, and .md file creation logic.
"""

import abc
import time
from pathlib import Path
from datetime import datetime, timezone
from typing import Optional

try:
    from Agents.config import NEEDS_ACTION_DIR, DRY_RUN, now_iso, now_local_iso
    from Agents.action_logger import log_action
except ImportError:
    from config import NEEDS_ACTION_DIR, DRY_RUN, now_iso, now_local_iso
    from action_logger import log_action


class BaseWatcher(abc.ABC):
    """
    Abstract base class for all watchers.

    Subclasses must implement:
        - name: str property
        - poll() -> list[dict]  ‚Äî returns new items found
    """

    POLL_INTERVAL: int = 30  # seconds between polls

    @property
    @abc.abstractmethod
    def name(self) -> str:
        """Unique name of this watcher (e.g. 'gmail_watcher')."""
        ...

    @abc.abstractmethod
    def poll(self) -> list[dict]:
        """
        Check the data source for new items.
        Returns a list of dicts, each with at least:
            - 'title': str
            - 'body': str
            - 'source': str  (e.g. email address, phone number)
            - 'priority': str  ('urgent', 'normal', 'low')
        """
        ...

    def setup(self) -> None:
        """Optional setup hook ‚Äî override if needed (e.g. auth)."""
        pass

    def teardown(self) -> None:
        """Optional cleanup hook ‚Äî override if needed."""
        pass

    # ------------------------------------------------------------------
    # Common functionality
    # ------------------------------------------------------------------

    def create_action_file(self, item: dict) -> Path:
        """
        Write a .md file to /Needs_Action for a detected item.
        Returns the path to the created file.
        """
        ts = datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%S")
        safe_title = "".join(
            c if c.isalnum() or c in " _-" else "_"
            for c in item.get("title", "untitled")
        )[:60].strip()
        filename = f"{ts}_{self.name}_{safe_title}.md"
        filepath = NEEDS_ACTION_DIR / filename

        priority = item.get("priority", "normal")
        priority_icon = {"urgent": "üî¥", "normal": "üü°", "low": "üü¢"}.get(
            priority, "‚ö™"
        )

        content = f"""---
source: {item.get('source', 'unknown')}
watcher: {self.name}
priority: {priority}
detected_at: {now_iso()}
status: needs_action
---

# {priority_icon} {item.get('title', 'Untitled')}

**From:** {item.get('source', 'unknown')}
**Detected by:** {self.name}
**Time:** {now_local_iso()}

---

{item.get('body', '(no content)')}

---

> *Auto-generated by {self.name}*
"""
        filepath.write_text(content, encoding="utf-8")

        log_action(
            action_type="watcher_detection",
            actor=self.name,
            target=filename,
            description=f"Detected: {item.get('title', 'untitled')} from {item.get('source', 'unknown')}",
            status="success" if not DRY_RUN else "dry_run",
        )

        return filepath

    def run_once(self) -> list[Path]:
        """Execute a single poll cycle and create action files."""
        items = self.poll()
        created = []
        for item in items:
            path = self.create_action_file(item)
            print(f"  üì•  [{self.name}] {item.get('title', '?')} ‚Üí {path.name}")
            created.append(path)
        if not items:
            print(f"  ‚úÖ  [{self.name}] No new items.")
        return created

    def watch_loop(self) -> None:
        """Continuously poll until interrupted."""
        print(f"üëÅÔ∏è  {self.name} started ‚Äî polling every {self.POLL_INTERVAL}s")
        print(f"    Dry-run: {DRY_RUN}  |  Press Ctrl+C to stop\n")
        self.setup()
        try:
            while True:
                try:
                    self.run_once()
                except Exception as e:
                    print(f"  ‚ö†Ô∏è  [{self.name}] Error during poll: {e}")
                    log_action(
                        action_type="watcher_error",
                        actor=self.name,
                        target="poll",
                        description=str(e),
                        status="failed",
                    )
                time.sleep(self.POLL_INTERVAL)
        except KeyboardInterrupt:
            print(f"\nüõë  {self.name} stopped by user.")
        finally:
            self.teardown()
